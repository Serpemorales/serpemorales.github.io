{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"practica2_1/","title":"Pr\u00e1ctica 2.1 - Instalaci\u00f3n y configuraci\u00f3n de servidor web Nginx","text":""},{"location":"practica2_1/#instalacion-servidor-web-nginx","title":"Instalaci\u00f3n servidor web nginx","text":"<p>Primero tenemos que instalar el servidor nginx, actualizando los repositorios e instal\u00e1ndolo desde la consola.</p> <p></p>"},{"location":"practica2_1/#creacion-de-la-carpeta-del-sitio-web","title":"Creaci\u00f3n de la carpeta del sitio web","text":"<p>Todos los archivos que forman parte del sitio web tendr\u00e1n que organizarse en carpetas, que normalmente las encontramos en /var/www.</p> <p>Creamos el directorio sin mayor problema, y una vez creado, nos aseguramos de que tenemos git instalado para poder clonar el repositorio de github proporcionado.</p> <p></p> <p>Tras clonar el repositorio, haremos que el propietario de la carpeta y todo lo de dentro sera el usuario www-data, utilizando los siguientes comandos.</p> <p></p> <p>Si todo ha salido bien, utilizando la IP de la maquina virtual, nos permitir\u00e1 acceder a una web donde se muestra un mensaje</p> <p></p>"},{"location":"practica2_1/#configuracion-del-servidor-web-nginx","title":"Configuraci\u00f3n del servidor web NGINX","text":"<p>En Nginx hay dos rutas importantes, tenemos sites-available, la cual tiene los archivos de configuraci\u00f3n de hosts virtuales o los bloques disponibles en el servidor. La otra es sites-enabled, que contiene los archivos de configuraci\u00f3n de los sitios habilitados.</p> <p>Para que Nginx presente el contenido de nuestra propia web, tenemos que crear un bloque de servidor con todas las directivas correctas, y lo haremos modificando el archivo de configuraci\u00f3n predeterminado, utilizando la consola.</p> <p></p> <p>Despu\u00e9s, crearemos un archivo simb\u00f3lico entre el archivo y el de los sitios habilitados.</p> <p></p> <p>Reiniciamos el servidor, para asegurarnos de que se aplica toda la nueva configuraci\u00f3n</p> <p></p>"},{"location":"practica2_1/#comprobaciones","title":"Comprobaciones","text":"Comprobaci\u00f3n del correcto funcionamiento <p>Como no tenemos un servidor DNS, tendremos que hacerlo de manera manual. Para ello, tenemos que editar el archivo que se encuentra en /etc/hosts de nuestra maquina principal, a\u00f1adiendo al archivo la siguiente l\u00ednea</p> <p></p> Comprobaci\u00f3n de los registros del servidor <p>Para ver que todo se esta registrando correctamente en los logs, vamos a utilizar dos comandos en la consola que nos dar\u00e1n acceso a estos.</p> <p></p> <p></p>"},{"location":"practica2_1/#ftp","title":"FTP","text":"<p>Vamos a configurar el protocolo de transferencia de archivos FPT, que es una manera de transferir a trav\u00e9s de una red TCP.</p> <p>En nuestro caso, vamos a configurar un servidor SFTP, que es lo mismo pero a\u00f1adiendo una capa de seguridad y privacidad al propio FTP.</p> Configurar servidor SFTP en Debian <p>Primero instalamos todo desde los siguientes repositorios.</p> <p> Despu\u00e9s creamos una carpeta en el home de Debian</p> <p></p> <p>Ahora tenemos que crear unos certificados de seguridad que son necesarios para aportar la capa de cifrado a la conexi\u00f3n. </p> <p></p> <p>Ya terminados estos pasos, vamos a realizar la configuraci\u00f3n del propio vsftpd, en mi caso he utilizado nano como editor de texto, borrando las l\u00edneas de archivo</p> <pre><code>rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem\nrsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key\nssl_enable=NO\n</code></pre> <p>Para a\u00f1adir otras en su lugar</p> <p></p> <p>Guardamos cambios del archivo, y volvemos a reiniciar para que coja la configuraci\u00f3n nueva que hemos a\u00f1adido.</p> <p></p> <p>Tras todo esto, ya podemos acceder al servidor, y para ello vamos a necesitar un cliente FTP, en mi caso, he descargado Filezilla</p> <p></p> <p>Una vez instalado, podemos conectarnos de manera insegura con el puerto 21, o con el 22, en mi caso, prob\u00e9 primero el 21 y despu\u00e9s el 22, introduciendo los datos necesarios para conectar al servidor.</p> <p></p> <p>Tras darla a conexi\u00f3n r\u00e1pida saldr\u00e1 un aviso, le daremos a aceptar sin ning\u00fan problema.</p> <p></p> <p>Utilizando las carpetas de la parte izquierda, nos aseguraremos de subir un archivo a la carpeta FTP del servidor, en mi caso, como prueba he subido una imagen</p> <p></p> <p>Para probar que todo ha ido bien, volvemos a la m\u00e1quina virtual, y deber\u00edamos tener all\u00ed el archivo transferido</p> <p></p>"},{"location":"practica2_1/#https","title":"HTTPS","text":"<p>Vamos a a\u00f1adir al servidor una capa de seguridad extra y necesaria, para obligar a nuestros sitios web a hacer uso de los certificados SSL y acceder a ellos mediante HTTPS.</p> <p>Lo primero que hacemos es generar los certificados autofirmados</p> <p></p> <p>Y despu\u00e9s, debemos ir al fichero de configuraci\u00f3n del host virtual, para cambiar los par\u00e1metros de la siguiente manera, asegur\u00e1ndonos de que si entramos por HTTP nos redirigir\u00e1 autom\u00e1ticamente al HTTPS</p> <p></p> <p>Para comprobarlo, vamos a intentar entrar en la web, y vemos que efectivamente, nos redirige a la web HTTPS.</p> <p></p>"},{"location":"practica2_1/#cuestiones","title":"Cuestiones","text":"Cuesti\u00f3n 1  &gt; \u00bfQu\u00e9 pasa si no hago el link simb\u00f3lico entre `sites-available` y &gt; `sites-enabled` de mi sitio web?  Si no realizamos el link simb\u00f3lico, no se dar\u00e1 de alta autom\u00e1ticamente nuestra configuraci\u00f3n y no ser\u00e1 activada, pues Nginx busca las configuraciones activas una vez est\u00e1n enlazadas. Cuesti\u00f3n 2  &gt; \u00bfQu\u00e9 pasa si no le doy los permisos adecuados a `/var/www/nombre_web`?  Si no le damos los permisos adecuados, nos dar\u00e1 un error de acceso no autorizado cuando intentemos entrar en la p\u00e1gina web. B\u00e1sicamente, nuestra web no funcionar\u00e1 correctamente."},{"location":"practica2_2/","title":"Pr\u00e1ctica 2.2 - Autenticaci\u00f3n en Nginx","text":""},{"location":"practica2_2/#comprobacion-de-paquetes","title":"Comprobaci\u00f3n de Paquetes","text":"<p>Primero, comprobamos que los paquetes necesarios est\u00e1n instalados. En mi caso lo est\u00e1n.</p> <p></p>"},{"location":"practica2_2/#creacion-de-usuarios-y-contrasenas-para-el-acceso-web","title":"Creaci\u00f3n de usuarios y contrase\u00f1as para el acceso web","text":"<p>Vamos a crear un archivo oculto que se llama .htpasswd. Lo vamos a crear en el directorio de configuraci\u00f3n /etc/nginx donde se pueda guardar el usuario y la contrase\u00f1a. Como se puede repetir con tantos usuarios como haga falta, lo he realizado con mi nombre y mi apellido.</p> <p> </p> <p>Compruebo que todo est\u00e9 correcto.</p> <p></p>"},{"location":"practica2_2/#configurando-el-servidor-nginx-para-usar-autenticacion-basica","title":"Configurando el servidor Nginx para usar autenticaci\u00f3n b\u00e1sica","text":"<p>Lo primero va a ser configurar nuestra web para a\u00f1adir la directiva auth_basic y as\u00ed proteger la web.</p> <p></p> <p>Una vez guardada la configuraci\u00f3n, reiniciamos el servidor</p> <p></p>"},{"location":"practica2_2/#probando-la-nueva-configuracion","title":"Probando la nueva configuraci\u00f3n","text":"<p>Tras esto, he comprobado que desde mi m\u00e1quina f\u00edsica he podido acceder al sitio y me ha pedido autentificaci\u00f3n</p> <p></p> <p>Y si cancelo la autentificaci\u00f3n sale el error 401</p> <p></p> <p>Ahora, para la Tarea 1, he intentado entrar con un usuario err\u00f3neo, y luego con uno correcto.</p> <p>Accedo a los log de acceso y error para que se vean ambos intentos.</p> <p>En el de acceso vemos como nos muestra que no hay ning\u00fan problema</p> <p></p> <p>Mientras que en el de error vemos que nos dice que no se ha encontrado ese usuario en el archivo que creamos, dando lugar a que no pueda autentificarse.</p> <p></p> <p>Despu\u00e9s hemos tenido que configurar para que el servidor solo bloquee cierta parte de la web. En nuestro caso, no podemos bloquear solo contact, por lo que hice el ejemplo con el propio index.</p> <p></p>"},{"location":"practica2_2/#combinacion-de-la-autenticacion-basica-con-restriccion-por-ip","title":"Combinaci\u00f3n de la autenticaci\u00f3n b\u00e1sica con restricci\u00f3n por IP","text":"<p>Tambi\u00e9n tenemos la opci\u00f3n de permitir o denegar la entrada a la web a partir de las IP. con las directivas allow y deny. Adem\u00e1s, podemos tambi\u00e9n hacer que sea necesario tanto autentificarse con el usuario como tener la IP correcta.</p> <p>En la Tarea 1 de esta secci\u00f3n, ten\u00edamos que prohibir el acceso con la IP de la m\u00e1quina anfitriona, y comprobar que el acceso fuese denegado.</p> <p></p> <p>Y efectivamente, nos sale un error 403 cuando intentamos entrar</p> <p></p> <p>Tambi\u00e9n podemos ver el propio mensaje de error en el error.log</p> <p></p> <p>Para finalizar, configuramos para que necesitemos acceder desde la m\u00e1quina anfitriona tanto con una IP v\u00e1lida como con el usuario, ambas cosas a la vez. Tras poner las directivas, lo compruebo y funciona perfectamente.</p> <p></p> <p></p>"},{"location":"practica2_2/#cuestiones-finales","title":"Cuestiones finales","text":"<p>Cuestion 1</p> <p>Supongamos que yo soy el cliente con la IP 172.1.10.15 e intento acceder al directorio <code>web_muy_guay</code> de mi sitio web, equivoc\u00e1ndome al poner el usuario y contrase\u00f1a. \u00bfPodr\u00e9 acceder? \u00bfPor qu\u00e9?</p> <pre><code>    location /web_muy_guay {\n    #...\n    satisfy all;    \n    deny  172.1.10.6;\n    allow 172.1.10.15;\n    allow 172.1.3.14;\n    deny  all;\n    auth_basic \"Cuesti\u00f3n final 1\";\n    auth_basic_user_file conf/htpasswd;\n}\n</code></pre> <p>No se podr\u00e1, porque nos est\u00e1 pidiendo que tenemos que utilizar tanto una IP correcta como un usuario.</p> <p>Cuestion 2</p> <p>Supongamos que yo soy el cliente con la IP 172.1.10.15 e intento acceder al directorio <code>web_muy_guay</code> de mi sitio web, introduciendo correctamente usuario y contrase\u00f1a. \u00bfPodr\u00e9 acceder?\u00bfPor qu\u00e9?</p> <pre><code>    location /web_muy_guay {\n    #...\n    satisfy all;    \n    deny  all;\n    deny  172.1.10.6;\n    allow 172.1.10.15;\n    allow 172.1.3.14;\n\n    auth_basic \"Cuesti\u00f3n final 2: The revenge\";\n    auth_basic_user_file conf/htpasswd;\n    } \n</code></pre> <p>Si podremos acceder, ya que pese al deny all, se permite el acceso a nuestra IP, y adem\u00e1s, hemos introducido el usuario y contrase\u00f1a de manera correcta.</p> <p>Cuestion 3</p> <p>Supongamos que yo soy el cliente con la IP 172.1.10.15 e intento acceder al directorio <code>web_muy_guay</code> de mi sitio web, introduciendo correctamente usuario y contrase\u00f1a. \u00bfPodr\u00e9 acceder?\u00bfPor qu\u00e9?</p> <pre><code>    location /web_muy_guay {\n    #...\n    satisfy any;    \n    deny  172.1.10.6;\n    deny 172.1.10.15;\n    allow 172.1.3.14;\n\n    auth_basic \"Cuesti\u00f3n final 3: The final combat\";\n    auth_basic_user_file conf/htpasswd;\n}\n</code></pre> <p>No podremos acceder, puesto que aunque la directiva sea satisfy any, nuestra IP est\u00e1 denegada, y esa restricci\u00f3n tiene prioridad y bloquea el acceso.</p> <p>Cuestion 4</p> <p>Supongamos que quiero restringir el acceso al directorio de proyectos porque es muy secreto, eso quiere decir a\u00f1adir autenticaci\u00f3n b\u00e1sica a la secci\u00f3n de proyectos.</p> <p>Completa la configuraci\u00f3n para conseguirlo:</p> <pre><code>    server {\n        listen 80;\n        listen [::]:80;\n        root /var/www/freewebsitetemplates.com/preview/space-science;\n        index index.html index.htm index.nginx-debian.html;\n        server_name freewebsitetemplates.com www.freewebsitetemplates.com;\n        location              {\n\n            try_files $uri $uri/ =404;\n        }\n        location /Proyectos {\n            auth_basic \"\u00c1rea restringida\";\n            auth_basic_user_file /etc/nginx/.htpasswd;\n            try_files $uri $uri/ =404;\n        }\n    }\n</code></pre>"},{"location":"practica2_3/","title":"Pr\u00e1ctica 2.3 - Proxy Inverso con Nginx","text":""},{"location":"practica2_3/#clonacion-de-maquina-virtual","title":"Clonaci\u00f3n de M\u00e1quina Virtual","text":"<p>Primero vamos a tener que clonar la M\u00e1quina Virtual para as\u00ed tener dos servidores, el que ya ten\u00edamos de antes, y el del proxy. Es muy importante que generemos nuevas direcciones MAC en esta clonaci\u00f3n.</p> <p> </p> <p>Una vez tengamos las dos m\u00e1quinas, ya podemos empezar.</p> <p> </p>"},{"location":"practica2_3/#configuracion-maquina-principal","title":"Configuraci\u00f3n M\u00e1quina Principal","text":"<p>AVISO: Recordar a la hora de probar todo en el navegador desactivar la cach\u00e9 o utilizar ventana privada.</p> <p>Para preparar la m\u00e1quina principal, vamos a cambiar el nombre de nuestra web ya creada por <code>webserver</code>, y para ello tenemos que cambiar su nombre en todos los archivos que sean necesarios. Adem\u00e1s, haremos que el servidor en lugar de escuchar el puerto 80 escuche el 8080.</p> <p> </p> <p>Tras este cambio, es necesario que deshagamos el link simb\u00f3lico antiguo, y creemos uno nuevo, reiniciando tras esto Nginx.</p> <p> </p>"},{"location":"practica2_3/#configuracion-maquina-proxy","title":"Configuraci\u00f3n M\u00e1quina Proxy","text":"<p>Ahora tenemos que configurar esta m\u00e1quina para poder acceder al proxy por nuestra web. Para ello, vamos a crear en sites-avalaible un nuevo archivo, configur\u00e1ndolo de la siguiente forma.</p> <p> </p> <p>Como se ve, en mi caso le he a\u00f1adido ya el header, pero no es necesario por ahora.</p> <p>Tras esto, vamos a realizar el link simb\u00f3lico y a reiniciar nginx en esta m\u00e1quina, para dejar todo a punto .</p> <p> </p> <p>Es importante que modifiquemos tambi\u00e9n el archivo hosts, a\u00f1adiendo la IP de la m\u00e1quina que hace de proxy.</p> <p> </p>"},{"location":"practica2_3/#comprobaciones","title":"Comprobaciones","text":"<p>Dentro del navegador, si accedemos a las herramientas de desarrollador (En el caso de Firefox con F12) podremos comprobar que el estado sea 200 OK, indicando que todo est\u00e1 correcto.</p> <p> </p>"},{"location":"practica2_3/#anadir-cabecera","title":"A\u00f1adir cabecera","text":"<p>Como indiqu\u00e9 antes, ahora vamos a a\u00f1adir una cabecera, de esta manera podemos demostrar de forma m\u00e1s clara que la petici\u00f3n pasa por el proxy inverso y despu\u00e9s llega al servidor web por el mismo camino.</p> <p> </p> <p>Tras hacerlo en el proxy, lo haremos tambi\u00e9n en el del servidor web, de manera que quedar\u00eda as\u00ed.</p> <p> </p> <p>Es importante que sean nombres distintos, para que sepamos identificar bien cual es cada uno. En mi caso el del proxy se ha llamado <code>Proxy_inverso_sergio</code> y el del servidor web se ha llamado <code>servidor_web_sergio</code>.</p> <p>Ahora abrimos de nuevo la web, y volvemos a usar las herramientas de desarrollador de Firefox. Si todo va bien, podremos ver en la cabecera ambos host, de esta manera.</p> <p> </p>"},{"location":"practica2_4/","title":"Pr\u00e1ctica 2.4 - Balanceo de carga con proxy inverso en Nginx","text":""},{"location":"practica2_4/#preparacion","title":"Preparaci\u00f3n","text":"<p>Primero vamos a conectarnos con el SSH a nuestra m\u00e1quina.</p> <p> </p> <p>Y una vez conectados, vamos a desvincular los sitios web de las pr\u00e1cticas anteriores, para as\u00ed evitar problemas.</p> <p> </p> <p>Este proceso lo realizaremos con el resto de m\u00e1quinas tambi\u00e9n.</p>"},{"location":"practica2_4/#nginx-servidor-web-1","title":"Nginx Servidor Web 1","text":"<p>AVISO: Recordar a la hora de probar todo en el navegador desactivar la cach\u00e9 o utilizar ventana privada.</p> <p>Primero, vamos a crear en el primer servidor un nuevo directorio llamado webserver1, con su correspondiente carpeta HTML.</p> <p> </p> <p>Tras esto, vamos a crear el archivo HTML, que se ver\u00e1 de la siguiente manera. En el servidor 2 ser\u00e1 igual, pero cambiando el web 1 por 2.</p> <p> </p> <p>Una vez realizada esa configuraci\u00f3n, vamos a crear el webserver1, en mi caso, he copiado el webserver anterior para hacerlo mas f\u00e1cil, cambiando el archivo con las configuraciones nuevas.</p> <p> </p> <p> </p> <p>Una vez hecho esto, volvemos a hacer el link, y ya podremos pasar al segundo servidor.</p> <p> </p>"},{"location":"practica2_4/#nginx-servidor-web-2","title":"Nginx Servidor Web 2","text":"<p>Vamos a clonar el servidor 1, asegur\u00e1ndonos de que tiene una IP distinta al primero.</p> <p> </p> <p>Como tenemos que modificar todo lo del servidor 1, cambiamos el nombre de webserver1 a webserver2</p> <p> </p> <p>Cambiamos tambi\u00e9n el archivo HTML, de manera que se muestre que es el servidor 2 .  </p> <p>Y cambiamos el archivo de webserver2, dejando todo igual que el primero, pero cambiando el 1 por el 2. Al igual que antes, volvemos a hacer el proceso de vinculaci\u00f3n y reiniciamos en nginx.</p> <p></p> <p> </p>"},{"location":"practica2_4/#nginx-proxy-inverso","title":"Nginx Proxy Inverso","text":"<p>En el caso del proxy, tenemos que configurarlo para que realice el reparto de peticiones entre ambos servidores. En sites-available, vamos a crear un archivo de configuraci\u00f3n llamado balanceo, y dentro de se archivo, vamos a poner los siguientess datos.</p> <p> </p> <p>En el bloque de upstream, hemos puesto que vaya a uno de esos dos servidores de manera aleatoria, y esas ip pertenecen cada una a uno de los dos servidores que hemos configurado. Hacemos el link correspondiente, y reiniciamos de nuevo, tras esta configuraci\u00f3n, solo nos queda cambiar el archivo hosts de nuestra m\u00e1quina principal y podremos pasar a realizar las comprobaciones.</p> <p> </p> <p> </p>"},{"location":"practica2_4/#comprobaciones","title":"Comprobaciones","text":"<p>Vamos a realizar las comprobaciones, tras poner el nombre de nuestra web, nos va redirigiendo a uno u otro de manera aleatoria, adem\u00e1s, comprobamos con las herramientas de desarrollador que se muestra el header que pusimos.</p>"},{"location":"practica2_4/#servidor-web-1","title":"Servidor web 1","text":""},{"location":"practica2_4/#servidor-web-2","title":"Servidor web 2","text":""},{"location":"practica2_4/#comprobacion-con-caida-de-servidor","title":"Comprobaci\u00f3n con caida de servidor","text":"<p>Tras cerrar el Servidor n\u00famero 1, sigo refrescando la p\u00e1gina, y ahora solo aparece el servidor n\u00famero 2, por lo que todo est\u00e1 correcto.</p> <p> </p> <p> </p>"},{"location":"practica2_4/#cuestiones","title":"Cuestiones","text":""},{"location":"practica2_4/#cuestion-1","title":"Cuesti\u00f3n 1","text":"<p>Busca informaci\u00f3n de qu\u00e9 otros m\u00e9todos de balanceo se pueden aplicar con Nginx y describe al menos 3 de ellos.</p> <p>IP-hash: este m\u00e9todo utiliza un algoritmo que toma la direcci\u00f3n IP de origen y destino del cliente y el servidor para generar una clave hash \u00fanica. IT permite la persistencia de la sesi\u00f3n.</p> <p>Round-robin: es el m\u00e9todo predeterminado para el equilibrio de carga. Indica al equilibrador de carga que vuelva a la parte superior de la lista y se repita de nuevo.</p> <p>\"El Menos conectado\": este m\u00e9todo utiliza un algoritmo de equilibrio de carga din\u00e1mico. Redistribuye las conexiones al miembro del grupo que administran la menor cantidad de conexiones abiertas en el momento en que se recibe la nueva solicitud de conexi\u00f3n.</p>"},{"location":"practica2_4/#cuestion-2","title":"Cuesti\u00f3n 2","text":"<p>Si quiero a\u00f1adir 2 servidores web m\u00e1s al balanceo de carga, describe detalladamente qu\u00e9 configuraci\u00f3n habr\u00eda que a\u00f1adir y d\u00f3nde.</p> <p>Una vez ya tengamos configurados esos 2 servidores nuevos, ser\u00eda tan sencillo como a\u00f1adir sus IP y puertos a la secci\u00f3n de y colocarlas en el bloque de upstream, siguiendo las otras IP de la misma manera que configuramos las anteriores.</p>"},{"location":"practica2_4/#cuestion-3","title":"Cuesti\u00f3n 3","text":"<p>Describir los pasos a seguir para configurar un balanceo de carga con una de las webs de pr\u00e1cticas anteriores.</p> <p>Lo primero ser\u00eda modificar el archivo del proxy inverso, para poder a\u00f1adir el bloque de upstream, con las correspondientes IP de los servidores, tambi\u00e9n, si queremos que sea random, a\u00f1adirle el random para que decida uno de estos.</p> <p>Despu\u00e9s, tendr\u00edamos que definir el bloque location en el proxy_pass, para asegurarnos de que las peticiones recibidas se muevan a uno de los servidores que tendremos activos.</p> <p>Realmente, respecto a la pr\u00e1ctica anterior, no ser\u00edan demasiados cambios, mas all\u00e1 de modificar el proxy, y asegurarnos de que cada servidor tiene su IP y sus identificaciones correctas.</p>"},{"location":"practica2_5/","title":"Pr\u00e1ctica 2.5 - # Proxy inverso y balanceo de carga con SSL en NGINX","text":""},{"location":"practica2_5/#creacion-de-certificado-autofirmado","title":"Creaci\u00f3n de certificado autofirmado","text":"<p>Para comenzar el proceso, tenemos que crear un certificado autofirmado en nuestra m\u00e1quina que contenga el proxy inverso, y para comenzar, tenemos que crear un directorio de la siguiente manera.</p> <p> </p> <p>Una vez creado, podemos proceder a la creaci\u00f3n del certificado, introduciendo los par\u00e1metros que nos van pidiendo.</p> <p>Los datos que se ven en el comando son los siguientes:</p> <ul> <li> <p>openssl: es la herramienta de l\u00ednea de comandos que usamos para gestionar certificados, claves y otros archivos relacionados con OpenSSL.</p> </li> <li> <p>req: este subcomando se usa para generar solicitudes de certificado, o tambi\u00e9n solicitudes de firma de certificados (CSR).</p> </li> <li> <p>-x509: al a\u00f1adir esta opci\u00f3n, le indicamos a OpenSSL que queremos un certificado autofirmado en lugar de una solicitud de firma de certificado.</p> </li> <li> <p>-nodes: le dice a OpenSSL que no proteja el certificado con una contrase\u00f1a. Esto es importante para que Nginx pueda leer el archivo sin pedir una contrase\u00f1a cada vez que se reinicia el servidor.</p> </li> <li> <p>-days 365: define la duraci\u00f3n de validez del certificado; en este caso, lo configuramos para un a\u00f1o.</p> </li> <li> <p>-newkey rsa:2048: especifica que generaremos un nuevo certificado y una clave al mismo tiempo. Elegimos una clave RSA de 2048 bits para asegurarla.</p> </li> <li> <p>-keyout: le indica a OpenSSL d\u00f3nde guardar el archivo con la clave privada.</p> </li> <li> <p>-out: le dice a OpenSSL d\u00f3nde guardar el archivo del certificado que estamos creando.</p> </li> </ul> <p> </p>"},{"location":"practica2_5/#configuracion-ssl-en-el-proxy-inverso","title":"Configuraci\u00f3n SSL en el Proxy Inverso","text":"<p>AVISO: Recordar a la hora de probar todo en el navegador desactivar la cach\u00e9 o utilizar ventana privada.</p> <p>Ahora vamos a modificar el archivo que ya ten\u00edamos creado llamado balanceo, cambiando el bloque server y cambiando el puerto de escucha 80, a\u00f1adiendo las configuraciones que veremos en la imagen a continuaci\u00f3n.</p> <p> </p> <p>Tras este cambio, vamos a reiniciar nginx para que los cambios aparezcan.</p> <p> </p>"},{"location":"practica2_5/#comprobaciones","title":"Comprobaciones","text":"<p>Ahora, cuando entremos en nuestra web, nos saltar\u00e1 un aviso, puesto que nuestro certificado es autofirmado. Aceptamos, ya que no hay problema, puesto que nuestro certificado es seguro, ya que lo hemos generado nosotros. Una vez en la web, vamos a comprobar que el certificado es correcto. Pulsando en el candado, le damos a m\u00e1s informaci\u00f3n.</p> <p> </p> <p>Despu\u00e9s, en el apartado de seguridad le daremos a ver certificado.</p> <p> </p> <p>Ah\u00ed ya podremos ver todos los datos de nuestro certificado, como en la siguiente imagen.</p> <p> </p> <p>Si intent\u00e1semos acceder al http, nos sale la web b\u00e1sica de nginx, porque por ahora no nos est\u00e1 redirigiendo al https.</p> <p> </p>"},{"location":"practica2_5/#redireccion-forzosa-a-https","title":"Redirecci\u00f3n forzosa a HTTPS","text":"<p>Para que no importe desde donde accedemos a la web, vamos a a\u00f1adir un nuevo bloque server, para que nos redirija autom\u00e1ticamente al HTTPS.</p> <p>As\u00ed quedar\u00eda el nuevo bloque junto al anterior.</p> <p> </p> <p>Como de costumbre, reiniciamos NGINX para reflejar los cambios.</p> <p> </p> <p>Tras esto, compruebo que efectivamente, al ir por HTTP, me redirige autom\u00e1ticamente al HTTPS.</p> <p> </p> <p>Para comprobarlo mejor, vamos a ver los logs de acceso, tanto del HTTP como del HTTPS</p> <p> </p> <p> </p>"},{"location":"practica2_5/#cuestiones-finales","title":"Cuestiones finales","text":""},{"location":"practica2_5/#cuestion-1","title":"Cuestion 1","text":"<p>Hemos configurado nuestro proxy inverso con todo lo que nos hace falta pero no nos funciona y da un error del tipo <code>This site can't provide a secure connection, ERR_SSL_PROTOCOL_ERROR.</code></p> <p>Dentro de nuestro server block tenemos esto:</p> <pre><code>server {\n    listen 443;\n    ssl_certificate /etc/nginx/ssl/enrico-berlinguer/server.crt;\n    ssl_certificate_key /etc/nginx/ssl/enrico-berlinguer/server.key;\n    ssl_protocols TLSv1.3;\n    ssl_ciphers ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:ECDH+3DES:DH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!MD5:!DSS;\n    server_name enrico-berlinguer;\n    access_log /var/log/nginx/https_access.log;\n\n    location / {\n        proxy_pass http://red-party;\n        }\n    }\n</code></pre> <p>El error que vemos es un error de SSL, y es porque en el comienzo del server, nos falta un ssl al lado del listen 443, de manera que quede como</p> <p><code>listen 443 ssl;</code></p>"},{"location":"practica2_5/#cuestion-2","title":"Cuestion 2","text":"<p>\u00bfC\u00f3mo solucionamos el siguiente error?</p> <p> </p> <p>Este error, <code>NET::ERR_CERT_REVOKED</code>, significa que el certificado SSL del sitio ha sido revocado por la autoridad de certificaci\u00f3n (CA) que lo emiti\u00f3. Esto puede ocurrir por varias razones, como problemas de seguridad, la expiraci\u00f3n del certificado, o incluso un error administrativo.</p> <p>Para intentar solucionarlo, primero verificamos si el certificado realmente ha sido revocado. Si es as\u00ed, solicitamos un nuevo certificado y lo reemplazamos en la configuraci\u00f3n de Nginx, asegur\u00e1ndonos de reiniciar el servidor para aplicar los cambios. Tambi\u00e9n podemos intentar limpiar la cach\u00e9 del navegador o probarlo en otro navegador, ya que a veces el problema puede estar relacionado con la cach\u00e9 del certificado en el navegador.</p>"},{"location":"practica3_1/","title":"Pr\u00e1ctica 3.1: Instalaci\u00f3n de Tomcat","text":""},{"location":"practica3_1/#instalacion-de-tomcat","title":"Instalaci\u00f3n de Tomcat","text":"<p>Lo primero va a ser instalar nuestro Tomcat, la manera m\u00e1s recomendable es con el administrador de paquetes, siguiendo alg\u00fan tutorial online. No deber\u00eda darnos demasiados problemas, hasta comprobar que se ha instalado correctamente</p> <p> </p> <p>Una vez instalado, vamos a nuestra URL para ver que se visualiza de forma correcta, entrando con el usuario y contrase\u00f1a que hemos elegido.</p> <p> </p>"},{"location":"practica3_1/#despliegue-manual-mediante-la-gui-de-administracion","title":"Despliegue manual mediante la GUI de administraci\u00f3n","text":"<p>Ahora vamos a probar a realizar un despliegue manual de una aplicaci\u00f3n empaquetada en formato WAR, para ello, en la p\u00e1gina que hemos visto antes, buscamos la secci\u00f3n que permite desplegar el WAR, seleccionando nuestro archivo</p> <p> </p> <p>Tras esto, le damos a desplegar, y ya nos saldr\u00e1 como un directorio m\u00e1s al que tendremos acceso</p> <p> </p>"},{"location":"practica3_1/#despliegue-con-maven","title":"Despliegue con Maven","text":"<p>Instalaci\u00f3n de Maven</p> <p>Ahora vamos a realizar un despliegue con Maven, pero primero, vamos a instalarlo. Yo lo har\u00e9 mediante el gestor de paquetes APT, y para ello, empezaremos con una actualizaci\u00f3n de los repositorios </p> <p> </p> <p>Despu\u00e9s, si ha ido todo correcto, vamos a instalar Maven</p> <p> </p> <p>y para finalizar, vamos a comprobar que se instal\u00f3 de manera adecuada con el siguiente comando</p> <p> </p> <p>Configuraci\u00f3n de Maven</p> <p>Para que podamos realizar los despliegues, vamos a tener que hacer una correcta configuraci\u00f3n.</p> <p>Vamos a comenzar a\u00f1adiendo roles a nuestro usuario en Tomcat, es importante y bastante recomendable que los roles manager-script/manager-jmx no los tenga el mismo usuario que tenga el rol de manager-gui, por eso en mi caso, voy a separarlos.</p> <p>En el archivo tomcat-users.xml, vamos a modificar de manera que quede as\u00ed</p> <p> </p> <p>Tras esto, nos toca editar el archivo de maven, dentro de la carpeta, estar\u00e1 settings.xml, aqu\u00ed tenemos que poner un identificador para el servidor sobre el que vamos a desplegar y las credenciales, importante que todo sea dentro del bloque servers del XML</p> <p> </p> <p>Por \u00faltimo, vamos a modificar el POM del proyecto para hacer referencia a que el despliegue se realice con el plugin de Maven para Tomcat, en mi caso, he utilizado el de rock paper scissors que nos ha proporcionado la propia pr\u00e1ctica. Clonando el repositorio y modificando su correspondiente archivo POM, a\u00f1adiendo un bloque nuevo al final.</p> <p> </p> <p> </p> <p>Despliegue</p> <p>Una vez hecho esto, reiniciamos tomcat para que pille bien las configuraciones, y as\u00ed nos preparamos para desplegar nuestra aplicaci\u00f3n</p> <p> </p> <p>Vamos a utilizar el comando <code>mvn tomcat7:deploy</code></p> <p> </p> <p>Si vemos que hace deploying en nuestra url y que pone BUILD SUCCESS, es porque se ha desplegado con \u00e9xito. Podemos ir a la pagina de Tomcat para ver que efectivamente, esta ah\u00ed</p> <p> </p> <p>Y si pulsamos, est\u00e1 de manera totalmente funcional</p> <p> </p>"},{"location":"practica3_1/#cuestiones","title":"Cuestiones","text":"<p>Cuesti\u00f3n 1</p> <p>Hab\u00e9is visto que los archivos de configuraci\u00f3n que hemos tocado contienen contrase\u00f1as en texto plano, por lo que cualquiera con acceso a ellos obtendr\u00eda las credenciales de nuestras herramientas.</p> <p>En principio esto representa un gran riesgo de seguridad, \u00bfsabr\u00edas razonar o averiguar por qu\u00e9 esto est\u00e1 dise\u00f1ado de esta forma?</p> <p>El dise\u00f1o de herramientas como Tomcat asume que la seguridad de los archivos de configuraci\u00f3n recae en las pr\u00e1cticas de administraci\u00f3n del sistema y los permisos del entorno. Por ejemplo, en Tomcat se espera que los archivos de configuraci\u00f3n, como <code>tomcat-users.xml</code>, sean accesibles \u00fanicamente por el usuario que ejecuta el servidor y por root</p> <p>Mantener contrase\u00f1as en texto plano simplifica la configuraci\u00f3n y asegura la compatibilidad con est\u00e1ndares, pero tambi\u00e9n se basa en que el administrador del sistema configure permisos estrictos y garantice que el entorno sea seguro.</p>"},{"location":"practica3_2/","title":"Pr\u00e1ctica 3.2: Despliegue de aplicaciones con Node Express","text":""},{"location":"practica3_2/#instalacion-de-nodejs-express-y-test-de-la-primera-aplicacion","title":"Instalaci\u00f3n de Node.js, Express y test de la primera aplicaci\u00f3n","text":"<p>Antes de comenzar, vamos a desactivar Tomcat para evitar problemas.</p> <p> </p> <p>Tras esto, procedemos con la pr\u00e1ctica, y vamos a tener que instalar tanto Node.js como Express. Despu\u00e9s crearemos un archivo js y comprobaremos que nuestro primer despliegue funciona correctamente. Lo primero es instalar Node.JS, y empezamos con un update y upgrade de apt</p> <p> </p> <p> </p> <p>Una vez realizado esto, vamos ha a\u00f1adir un el repositorio de NodeJS con el siguiente comando.</p> <p> </p> <p>Ahora, podemos instalar NodeJS y comprobar que la instalaci\u00f3n es satisfactoria</p> <p> </p> <p> </p> <p>Una vez hecho esto, vamos con ExpressJS. Primero lo instalamos</p> <p> </p> <p>Y despu\u00e9s vamos a crear una carpeta para el proyecto, donde vamos a inicializarlo e instalarle express.</p> <p> </p> <p> </p> <p>Una vez seguidos estos sencillos pasos, vamos a crear un archivo de prueba llamado app.js, a\u00f1adiendo lo siguiente</p> <p></p> <p>Vamos a comprobar que todo ha ido bien, yendo al navegador y indicando nuestra ip seguida de :3000</p> <p></p>"},{"location":"practica3_2/#despliegue-de-una-nueva-aplicacion","title":"Despliegue de una nueva aplicaci\u00f3n","text":"<p>Ahora vamos a realizar un despliegue de una aplicaci\u00f3n de terceros, vamos a empezar clonando el repositorio de github correspondiente</p> <p></p> <p>Nos movemos al nuevo directorio creado, instalamos las librer\u00edas necesarias y iniciamos la aplicaci\u00f3n</p> <p></p> <p></p> <p></p> <p>Como vemos, nos sale un error en el que nodemon no se encuentra, para solucionar el problema es tan sencillo como instalarlo, de la siguiente manera</p> <p></p> <p>Una vez instalado, podemos ir a nuestra IP:3000 y ver como efectivamente, se ha desplegado</p> <p></p>"},{"location":"practica3_2/#cuestiones","title":"Cuestiones","text":"<p>Cuando ejecutamos el comando npm run start, lo que estamos haciendo es ejecutar un script:</p> <p>\u00bfDonde podemos ver que script se est\u00e1 ejecutando?</p> <p>Podemos verlo dentro del archivo package.json, concretamente dentro del objeto scripts.</p> <p>\u00bfQue comando est\u00e1 ejecutando?</p> <p>Se ejecuta el comando node server.js</p>"},{"location":"practica3_3/","title":"Pr\u00e1ctica 3.3: Despliegue de una aplicaci\u00f3n React en Netlify (PaaS)","text":""},{"location":"practica3_3/#creacion-de-nuestra-aplicacion","title":"Creaci\u00f3n de nuestra aplicaci\u00f3n","text":"<p>Tras loguearnos por SSH en nuestro Debian, vamos a crear un directorio para albergar la aplicaci\u00f3n y crear 3 archivos, dos html y un js, que conformar\u00e1n la sencilla aplicaci\u00f3n de ejemplo. Deben quedar de la siguiente manera</p> <p> </p> <p></p> <p></p> <p></p> <p>Una vez creado el directorio y los archivos, vamos a utilizar el comando npm init y comprobar que nuestra aplicaci\u00f3n funciona correctamente de manera local</p> <p></p> <p></p> <p></p> <p>Vemos que efectivamente, funciona, con esto ya podr\u00edamos desplegarla en m\u00faltiples plataformas en la nube, como Heroku, AWS, GCP etc.</p>"},{"location":"practica3_3/#despliegue-en-netlify","title":"Despliegue en Netlify","text":"<p>Para este despliegue, vamos a tomar una aplicaci\u00f3n de ejemplo, para ello, vamos a colnar el repositorio correspondiente</p> <p></p> <p>Una vez creado, vamos a crear una cuenta en Netlify, pues la necesitaremos para realizar todo este proceso. Es muy importante que nos registremos solo con el e-mail, y a\u00fan no la vinculemos con github.</p> <p></p> <p>Ahora si podemos empezar con el despliegue mediante CLI, para ello, vamos a tener que instalarlo con el siguiente comando</p> <p></p> <p>Una vez instalado, nos identificaremos en nuestra cuenta de netlify para poder utilizarla sin problema desde la consola de comandos</p> <p></p> <p>Para poder desplegar todo sin complicaci\u00f3n, vamos a tener que instalar todas las dependencias del archivo package.json, por lo que usaremos npm install, y despu\u00e9s haremos un run build para contener la aplicaci\u00f3n que debemos desplegar.</p> <p></p> <p></p> <p>Con todo esto ya creado, podemos proceder a desplegar la aplicaci\u00f3n en en Netlify. Nos har\u00e1 algunas preguntas, debemos indicar que queremos crear y configurar un nuevo sitio, dejaremos el Team por defecto, e indicaremos que queremos ponerle de nombre \"nombre\"-practica3-4 y utilizaremos el directorio ./build.</p> <p></p> <p></p> <p>Una vez terminado, si todo ha ido bien, nos saldr\u00e1 un mensaje y un borrador. Si el borrador esta bien, podemos pasar a desplegar la aplicaci\u00f3n. Nos dar\u00e1n un link para comprobar que esta todo bien.</p> <p></p> <p></p>"},{"location":"practica3_3/#despliegue-mediante-conexion-con-github","title":"Despliegue mediante conexi\u00f3n con Github","text":"<p>Ahora vamos a desplegar mediante una conexi\u00f3n con Github, para ello, vamos a empezar borrando el despliegue en Netlify, para evitar problemas. Tambi\u00e9n aprovecharemos para borrar el directorio donde hicimos el clonado del repositorio de Github.</p> <p></p> <p></p> <p>Como la idea es simular que lo vamos a subir a Github por primera vez, en vez de hacer un clonado, vamos a obtener el zip sin que tenga ninguna referencia a Github</p> <p></p> <p>Una vez lo tengamos, vamos a crear una carpeta nueva y a descomprimir aqu\u00ed el correspondiente ZIP que hemos descargado.</p> <p></p> <p>Ahora vamos a Github para crear un repositorio completamente vac\u00edo, que ser\u00e1 donde subiremos lo que hemos descargado.</p> <p></p> <p>Una vez hecho esto, vamos a proceder a desplegar la aplicaci\u00f3n en el repositorio de Github, realizando todo el proceso para hacer el push y subir todo el contenido.</p> <p></p> <p></p> <p></p> <p>Con esto ya tenemos todo el c\u00f3digo en GitHub, y vamos a tener que vincular nuestra cuenta de Github con la de Netlify, vamos a importar un proyecto en Netlify, d\u00e1ndole a importar desde Github.</p> <p></p> <p>Vamos a especificar que solo sea el repositorio que hemos creado anteriormente.</p> <p></p> <p>Y ya quedar\u00e1 listo, despleg\u00e1ndose la aplicaci\u00f3n, ya que Netlifyse encarga de hacer el build de forma autom\u00e1tica.</p> <p></p> <p>Ahora, cuando hagamos un cambio en el proyecto y hagamos un commit push en Github, autom\u00e1ticamente se generar\u00e1 un nuevo despliegue en Netlify. Para ello, haremos unas comprobaciones, vamos a ver que el archivo robots.txt, est\u00e1 de la siguiente manera.</p> <p></p> <p>Una vez comprobado, vamos a modificar el archivo, que est\u00e1 en la carpeta public, y vamos a a\u00f1adir en Disallow nuestro nombre y apellido de la siguiente manera.</p> <p></p> <p>Una vez hecho el cambio, volvemos a hacer un despliegue en Github, podemos comprobar con date que se ha producido el deploy.</p> <p></p> <p></p> <p>En el dashboard de Netlify podemos comprobar que se ha producido un deploy, y vemos como esta haciendo el Building.</p> <p></p> <p>Y cuando termina, volvemos a ir al archivo robots.txt, y efectivamente, veremos el cambio reflejado.</p> <p></p>"},{"location":"practica3_4/","title":"Pr\u00e1ctica 3.4: Despliegue de una aplicaci\u00f3n Flask (Python)","text":""},{"location":"practica3_4/#procedimiento-completo-para-el-despliegue","title":"Procedimiento completo para el despliegue","text":"<p>Vamos a comenzar a realizar el procedimiento para poder desplegar la aplicaci\u00f3n Flask. Vamos a comenzar instalando el gestor de paquetes de Python pip.</p> <p> </p> <p>Cuando hemos instalado este gestor de paquetes, ya podemos instalar el paquete pipenv, el cual nos va a servir para gestionar nuestros entornos virtuales, necesarios para esta pr\u00e1ctica.</p> <p> </p> <p>Comprobamos que se ha instalado correctamente, mostrando su versi\u00f3n en consola, y acto seguido tras comprobarlo, creamos un directorio para almacenar nuestro proyecto.</p> <p> </p> <p> </p> <p>Como hemos creado el directorio con sudo, los permisos de este directorio van a pertenecer a root. Vamos a cambiarlo, pues es importante para que Nginx no de errores al acceder a la aplicaci\u00f3n.</p> <p> </p> <p> </p> <p>Una vez ya asignados los permisos, vamos a crear un archivo oculto .env, dentro vamos a poner todas las variables de entorno necesarias. Por eso, tras crearlo, vamos a editar el archivo y a\u00f1adirlas, indicando el archivo py y el entorno.</p> <p> </p> <p> </p> <p>Ya con este archivo creado, vamos a iniciar nuestro entorno virtual, y podremos comprobar si se ha iniciado correctamente mirando el nombre antes de nuestro usuario.</p> <p> </p> <p>Ya en nuestro entorno virtual, vamos a instalar las dependencias necesarias para el proyecto, de una manera muy sencilla.</p> <p> </p> <p>Ahora vamos a crear la aplicaci\u00f3n Flask, vamos a crear un archivo que contendr\u00e1 la aplicaci\u00f3n como tal, que ser\u00e1 application.py, y crearemos tambi\u00e9n wsgi.py, que se encargar\u00e1 de iniciar esta aplicaci\u00f3n.</p> <p> </p> <p> </p> <p>Una vez creados estos archivos y editados, vamos a correr la aplicaci\u00f3n, utilizando en nuestra aplicaci\u00f3n http://IPmaquinavirtual:5000 para poder acceder. Comprobamos que todo este correcto, mostr\u00e1ndose en pantalla.</p> <p> </p> <p> </p> <p>Bien, ya hemos comprobado que funciona, ahora comprobaremos que Gunicorn funciona, utilizando un comando para probar esta aplicaci\u00f3n, accediendo al navegador de la misma manera, y comprobando si vemos el mensaje por pantalla.</p> <p> </p> <p> </p> <p>Gunicorn funciona, por lo que a\u00fan estando en el entorno virutal, vamos a tomar nota de la ruta desde la que ejecutamos gunicorn, porque mas adelante ser\u00e1 necesaria.</p> <p> </p> <p>Ahora tendr\u00edamos que instalar Nginx, en nuestro caso lo ten\u00edamos de pr\u00e1cticas anteriores, pero nos aseguramos de que este en correcto funcionamiento, pues vamos a necesitarlo para el resto de la pr\u00e1ctica.</p> <p> </p> <p>Saldremos del entorno virutal, y vamos a crear un archivo para que systemd corra nuestro Gunicorn como si fuese otro servicio del sistema. Es importante rellenar bien todos los datos necesarios con los nuestros.</p> <p> </p> <p>Tras crearlo, procedemos a la activaci\u00f3n del servicio, y lo iniciamos para que est\u00e9 activo.</p> <p> </p> <p>Ahora vamos a configurar nuestro Nginx, al igual que en pr\u00e1cticas anteriores, vamos a dirigirnos a sites-available, lugar donde crearemos nuestro archivo y lo editaremos de la siguiente manera. Es importante que tras crearlo, realicemos el link simb\u00f3lico.</p> <p> </p> <p> </p> <p>Si queremos asegurarnos de que el link se ha creado correctamente, podemos hacerlo de la siguiente manera.</p> <p> </p> <p>Tambi\u00e9n vamos a asegurarnos de que Nginx no contiene errores, y tras eso, si todo est\u00e1 correcto, vamos a reiniciarlo y comprobar que sigue activo.</p> <p> </p> <p>Ahora ya no podemos utilizar la IP como antes para acceder, ahora necesitamos acceder por el server_name. Para poder hacerlo, vamos a tener que ir al archivo hosts de nuestra m\u00e1quina anfitriona, y editarlo para que quede de la siguiente manera.</p> <p> </p> <p>Ya con estos cambios, podemos acceder desde el navegador y comprobar que se despliega correctamente.</p> <p> </p>"},{"location":"practica3_4/#procedimiento-completo-para-el-despliegue-con-repositorio","title":"Procedimiento completo para el despliegue con repositorio","text":"<p>Ahora vamos a repetir todo el proceso, pero con una aplicaci\u00f3n que copiaremos desde un repositorio de github. Lo vamos a clonar en nuestro directorio /var/www</p> <p> </p> <p>Al igual que antes, vamos a dar los permisos adecuados para la carpeta, para que Nginx no tenga errores.</p> <p> </p> <p>Ahora vamos a crear y activar nuestro entorno virtual de la misma manera que antes. Adem\u00e1s, una vez activado, vamos a instalar las dependecias del proyecto de la aplicaci\u00f3n.</p> <p> </p> <p> </p> <p>Ya tras esto, vamos a instalar las dependecias restantes necesarias.</p> <p> </p> <p>Ahora no necesitamos crear una aplicaci\u00f3n flask, por lo que simplemente creamos el wsgi.py igual que antes, pero en lugar de poner \"from application import app\" simplemente poner \"from app import app\". Al igual que antes, inicializamos para comprobar que todo va bien, tanto desde el servidor web integrado de Flask como de Gunicorn. Recordar tambi\u00e9n apuntar la ruta de Gunicorn.</p> <p> </p> <p>Ya realizado esto, vamos a seguir con los pasos para utilizar Nginx. Al igual que antes, vamos a crear un servicio para que Gunicorn sea un servicio del sistema m\u00e1s, esta vez con la nueva ruta de Gunicorn</p> <p> </p> <p> </p> <p>Una vez creado, habilitado e iniciado el servicio, vamos a ir a a sites-available de nuestro Nginx, creando un archivo propio. Desvinculamos el anterior para asegurarnos de que no hay fallos.</p> <p> </p> <p>Recordad crear el enlace simb\u00f3lico de nuevo y reiniciar nginx. Cuando vamos que todo est\u00e1 correcto, tenemos que volver a editar el archivo hosts de nuestra m\u00e1quina anfitriona, si no no podremos acceder.</p> <p> </p> <p>Ya con nuestro enlace, accedemos a el desde el navegador, para ver que efectivamente, funciona correctamente.</p> <p></p>"},{"location":"practica3_4/#cuestiones","title":"Cuestiones","text":"<p>Cuestion 1 Busca, lee, entiende y explica qu\u00e9 es y para que sirve un servidor WSGI</p> <p>Un servidor WSGI es b\u00e1sicamente una especificaci\u00f3n que define como debe comunicarse un servidor web con una aplicaci\u00f3n Python, de manera que se facilite la interacci\u00f3n entre ambas. Act\u00faa como puente y mejora la compatibilidad entre ellas, y adem\u00e1s es un componente clave para el despliegue de aplicaciones web Python en producci\u00f3n. Su principal beneficio al final es la capacidad que tiene para permitir que las aplicaciones Python se puedan ejecutar en diferentes servidores web sin necesidad de que estos entiendan directamente el c\u00f3digo Python, asegurando que las aplicaciones sean mas portables.</p>"}]}